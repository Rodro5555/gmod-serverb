--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local Itemstore
do
  local _class_0
  local _parent_0 = XeninInventory.Importer
  local _base_0 = {
    __name = "Itemstore",
    __base = XeninInventory.Importer.__base,
    readTextData = function(self)
      local p = XeninUI.Promises.new()

      local files, dirs = file.Find("itemstore/*.txt", "DATA")
      local bank = {}
      local inv = {}

      local filesSize = #files
      local i = 1

      local co
      hook.Add("Think", "XeninInventory.ReadData", function()
        if (co != "finished" and (!co or !coroutine.resume(co))) then
          co = coroutine.create(function()
            for i = 0, filesSize - 1 do
              i = i + 1
              local fileName = files[i]
              local path = "itemstore/" .. tostring(fileName)
              local contents = file.Read(path)
              local tbl = util.JSONToTable(contents or "")
              if (!tbl or tbl == "") then continue end
              if (!tbl) then continue end
              local isInv = #fileName == 21
              local sid64 = fileName:sub(1, 17)
              local items = {}
              for i, v in pairs(tbl) do
                v.SteamID = sid64
                v.Slot = i

                local row = self:processRow(v, i)
                if (!row) then continue end

                items[i] = row
              end
              if isInv then
                inv[sid64] = items
              else
                bank[sid64] = items
              end

              if (i == filesSize) then
                co = "finished"

                local result = {
                  bank = bank,
                  inv = inv
                }
                self:setCache("inventory_data", result)
                p:resolve(result)
              end

              if (i % 200 == 0 && i != filesSize) then
                hook.Run("XeninInventory.Importer.Sleeping", i)

                coroutine.wait(0.175)
              end
            end
          end)
          coroutine.resume(co)

        end
      end)

      return p
    end,
    processRow = function(self, tbl, index)
      local settings = self:getCache("settings")
      local output = {}
      if (!tbl.Class) then return end
      if (tbl.Class == "") then return end

      local _class = tbl.Class
      if settings.whitelist_only then
        if (!XeninInventory:GetItem(_class)) then return end
      end

      local sid64 = tbl.SteamID
      local slot = tbl.Slot or index
      local data = tbl.Data and (istable(tbl.Data) and tbl.Data or (util.JSONToTable(tbl.Data) or {})) or {}
      local isWep = tbl.Class == "spawned_weapon"
      local isShip = tbl.Class == "spawned_shipment"
      local dropClass = tbl.Class
      local amount = data.Amount or data.amount or 1
      if (isWep or isShip) then
        data.Amount = nil
        data.amount = nil
        dropClass = isWep and data.Class or isShipment and data.Class or dropClass
      end

      return {
        ["class"] = _class,
        dropClass = dropClass,
        sid64 = sid64,
        slot = slot,
        data = data,
        amount = amount
      }
    end,
    readSQLData = function(self)
      local p = XeninUI.Promises.new()

      local processData = function(query)
        local _p = XeninUI.Promises.new()

        XeninUI:InvokeSQL(XeninInventory.Database:GetConnection(), query, "XeninInventory.Importer.readSQLData"):next(function(result)
          local rows = {}
          for i, v in ipairs(result) do
            local row = self:processRow(v, i)
            if (!row) then continue end

            table.insert(rows, row)
          end

          _p:resolve(rows)
        end, ErrorNoHalt)

        return _p
      end

      XeninUI.Promises.all({
        processData("SELECT * FROM Inventories"),
        processData("SELECT * FROM Banks")
      }):next(function(results)
        local tbl = {
          inv = results[1],
          bank = results[2]
        }

        self:setCache("inventory_data", tbl)
        p:resolve(tbl)
      end, ErrorNoHalt)

      return p
    end,
    readData = function(self, method, settings, override)
      if method == nil then method = "sqlite"
      end
      if settings == nil then settings = {}
      end
      self:setCache("settings", settings)

      if (!override) then
        local cache = self:getCache("inventory_data")
        if cache then
          return XeninUI.Promises.new():resolve(cache)
        end
      end

      if (method == "text") then
        return self:readTextData()
      else
        return self:readSQLData()
      end
    end,
    getInfo = function(self, override)
      local p = XeninUI.Promises.new()
      local cache = self:getCache("provider_info")
      if (cache and !override) then
        return p:resolve(cache)
      end

      local sqlMethod = XeninDB.isMySQL() and "mysql" or "sqlite"

      XeninUI:InvokeSQL(XeninInventory.Database:GetConnection(), "SELECT COUNT(*) AS amount FROM inventory", "XeninInventory.Importer.getProvider"):next(function(result)
        local tbl = {
          type = sqlMethod,
          amount = (((result and result[1]) and result[1].amount) * 2) or 0
        }

        self:setCache("provider_info", tbl)
        p:resolve(tbl, self)
      end, function(err)


        local tbl = {}
        local dirExists = file.IsDir("itemstore", "DATA")
        if dirExists then
          local files, dirs = file.Find("itemstore/*.txt", "DATA")
          tbl = {
            type = "text",
            amount = math.floor(#files / 2)
          }
        else
          tbl = {
          type = "not_installed"
          }
        end

        self:setCache("provider_info", tbl)
        p:resolve(tbl, self)
      end)

      return p
    end,
    importToInventory = function(self)
      local p = XeninUI.Promises.new()
      local settings = self:getCache("settings")
      if (!settings.inventory) then return p:resolve()end
      local data = self:getCache("inventory_data").inv
      local promises = {}

      XeninUI:InvokeSQL(XeninInventory.Database:GetConnection(), "DELETE FROM inventory_player", "XeninInventory.Importer.DeleteInventory"):next(function()
        for sid64, rows in pairs(data) do
          if (#rows == 0) then continue end

          for i, v in ipairs(rows) do
            table.insert(promises, XeninInventory.Database:SaveSlot(v.sid64, v.slot, v.dropClass, v["class"], v.amount or 1, v.data))
          end
        end

        XeninUI.Promises.all(promises):next(function()
          p:resolve()end)
      end)

      return p
    end,
    importToBank = function(self)
      local p = XeninUI.Promises.new()
      local settings = self:getCache("settings")
      if (!settings.bank) then return p:resolve()end
      local data = self:getCache("inventory_data").bank
      local promises = {}

      XeninUI:InvokeSQL(XeninInventory.Database:GetConnection(), "DELETE FROM inventory_bank", "XeninInventory.Importer.DeleteBank"):next(function()
        for sid64, rows in pairs(data) do
          if (#rows == 0) then continue end

          for i, v in ipairs(rows) do
            table.insert(promises, XeninInventory.Database:SaveBankSlot(v.sid64, v.slot, v.dropClass, v["class"], v.amount or 1, v.data))
          end
        end

        XeninUI.Promises.all(promises):next(function()
          p:resolve()end)
      end)

      return p
    end,
    __type = function(self)
      return "XeninInventory.Importer"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      Itemstore.__parent.__init(self)

      self:addSetting("inventory", "Import the players inventory?", true, "Checkbox")
      self:addSetting("bank", "Import the players bank?", true, "Checkbox")
      self:addSetting("whitelist_only", "Import <color=255,255,255>only</color> recognised/whitelisted items?", true, "Checkbox")
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  Itemstore = _class_0
end

XeninInventory.Importers:addImporter("ItemStore", Itemstore)

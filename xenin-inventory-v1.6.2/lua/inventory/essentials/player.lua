--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local function GetInventoryStructure(tbl)
  return {
    id = tonumber(tbl.slot),
    ent = tbl.ent,
    dropEnt = tbl.drop_ent,
    amount = tonumber(tbl.amount),
    data = util.JSONToTable(tbl.data)
  }
end

XeninInventory.GetInventoryStructure = GetInventoryStructure

hook.Add("PlayerInitialSpawn", "XeninInventory", function(ply)
  local inv = ply:XeninInventory()
  local sid64 = ply:SteamID64()

  XeninInventory.Database:GetInventory(sid64, function(inventory)
    XeninInventory.Database:GetBank(sid64, function(bank)
      if IsValid(ply) then
        inventory = inventory or {}
        bank = bank or {}

        local invTemp = {}
        for i, v in ipairs(inventory) do
          local struct = GetInventoryStructure(v)
          if (!XeninInventory:GetItem(struct.dropEnt)) then continue end

          invTemp[tonumber(v.slot)] = struct
        end
        local bankTemp = {}
        for i, v in ipairs(bank) do
          local struct = GetInventoryStructure(v)
          if (!XeninInventory:GetItem(struct.dropEnt)) then continue end

          bankTemp[tonumber(v.slot)] = struct
        end
        inv:SetInventory(invTemp)
        inv:SetBank(bankTemp)

        timer.Simple(3, function()
          if IsValid(ply) then
            inv:NetworkAll()
          end
        end)
      end
    end)
  end)
end)

hook.Add("PlayerDisconnected", "XeninInventory", function(ply)
  if XeninInventory.Config.WipeInventoryOnDisconnect then
    local sid64 = ply:SteamID64()

    XeninInventory.Database:Clear(sid64)
    XeninInventory.Database:Clear(sid64, true)
  end
end)

hook.Add("PlayerSay", "XeninInventory.Commands", function(ply, text)
  text = text:lower()
  local tbl = XeninInventory.Config.ChatCommands[text]
  local time = ply._nextChatCommand or 0

  if (tbl and time < CurTime()) then
    ply._nextChatCommand = CurTime() + 0.1
    tbl(ply, text)

    return ""
  end
end)

hook.Add("PlayerLoadout", "XeninInventory.SWEP", function(ply)
  if (IsValid(ply) and !ply:isArrested() and XeninInventory.Config.SpawnWithInventorySWEP) then
    ply:Give("inventory")
  end
end)

hook.Add("PlayerButtonDown", "XeninInventory", function(ply, keyCode)
  if (keyCode == XeninInventory.Config.ModifierKey) then
    ply.lAltDown = true
  end

  if (keyCode == XeninInventory.Config.AltKey and ply.lAltDown and XeninInventory.Config.PickUpWithALT) then
    local tr = util.TraceLine({
      start = ply:EyePos(),
      endpos = ply:EyePos() + ply:EyeAngles():Forward() * 250,
      filter = ply
    })

    ply:XeninInventory():Pickup(tr.Entity)
  end
end)

hook.Add("PlayerButtonUp", "XeninInventory", function(ply, keyCode)
  if (keyCode == XeninInventory.Config.ModifierKey) then
    ply.lAltDown = nil
  end

  if (keyCode == XeninInventory.Config.InventoryKey and XeninInventory.Config.InventoryKey) then
    ply:ConCommand("inventory")
  end
end)





hook.Add("Initialize", "XeninInventory.Override", function()
  timer.Simple(10, function()
    local PLY = FindMetaTable("Player")
    function PLY:dropDRPWeapon(weapon, callback, holster)
      callback = callback or function() end

      if (!IsValid(weapon) or weapon:GetModel() == "") then
        DarkRP.notify(self, 1, 4, DarkRP.getPhrase("cannot_drop_weapon"))

        return
      end

      local canDrop = hook.Run("canDropWeapon", self, weapon)
      if (!canDrop) then
        DarkRP.notify(self, 1, 4, DarkRP.getPhrase("cannot_drop_weapon"))

        return
      end

      if (!holster) then
        self:DoAnimationEvent(ACT_GMOD_GESTURE_ITEM_DROP)
      end

      local time = 0
      if holster then
        time = XeninInventory.Config.HolsterTime[weapon:GetClass()] or 1

        if (time > 1) then
          self:XeninInventory():Message("It will take " .. time .. " seconds to holster")
        end
      end

      local function Drop()
        if (!IsValid(self) or !IsValid(weapon)) then return end

        local ammo = self:GetAmmoCount(weapon:GetPrimaryAmmoType())
        self:DropWeapon(weapon)

        local ent = ents.Create("spawned_weapon")
        local model = (weapon:GetModel() == "models/weapons/v_physcannon.mdl" and "models/weapons/w_physics.mdl") or weapon:GetModel()
        model = util.IsValidModel(model) and model or "models/weapons/w_rif_ak47.mdl"

        ent:SetPos(self:GetShootPos() + self:GetAimVector() * 30)
        ent:SetModel(model)
        ent:SetSkin(weapon:GetSkin() or 0)
        ent:SetWeaponClass(weapon:GetClass())
        ent.nodupe = true
        ent.clip1 = weapon:Clip1()
        ent.clip2 = weapon:Clip2()
        ent.ammoadd = ammo

        hook.Call("onDarkRPWeaponDropped", nil, self, ent, weapon)

        self:RemoveAmmo(ammo, weapon:GetPrimaryAmmoType())
        self:RemoveAmmo(self:GetAmmoCount(weapon:GetSecondaryAmmoType()), weapon:GetSecondaryAmmoType())

        ent:Spawn()

        weapon:Remove()

        callback(ent)
      end

      if (time == 0) then
        Drop()
      else
        timer.Simple(time, Drop)
      end
    end
  end)
end)
